# 类模板

本节将介绍类模板

## 初始类模板

类模板不是类，只有实例化类模板，编译器才能生成实际的类。

### 定义类模板

下面是一个类模板，它和普通类的区别只是多了一个 `template<typename T>`

```cpp
template<typename T>
struct Test{};
```

和函数模板一样，其实类模板的语法也就是：

```cpp
template< 形参列表 > 类声明
```

几乎所有我们前面讲的，**函数模板中形参列表能写的东西，类模板都可以**。

同样的，我们的类模板一样可以用 `class` 引入类型形参名，一样不能用 `struct`

```cpp
template<class T>
struct Test{};
```

### 使用类模板

下面展示了如何使用类模板 `Test`

```cpp
template<typename T>
struct Test {};

int main(){
    Test<void> t;
    Test<int> t2;
    //Test t;       // Error!
}
```

我们必须显式的指明类模板的类型实参，并且没有办法推导，事实上这个空类在这里本身没什么意义。

或许我们可以这样：

```cpp
template<typename T>
struct Test{
    T t;
};
```

这理所应当，类模板能使用类模板形参，声明自己的成员，那么如何使用呢？

```cpp
// Test<void> t;  // Error!
Test<int> t2;     
// Test t3;       // Error!
Test t4{ 1 };     // C++17 OK！
```

- `Test<void>` 我们稍微带入一下，模板的 `T` 是 `void` 那 `T t` 是？所以很合理
- `Test t4{ 1 };` C++17 增加了类模板实参推导，也就是说类模板也可以像函数模板一样被推导，而不需要显式的写明数据了，这里的 `Test` 被推导为 `Test<int>`。

不单单是聚合体，当然，写构造函数也可以：

```cpp
template<typename T>
struct Test{
    Test(T v) :t{ v } {}
private:
    T t;
};
```

## 类模板参数推导

这涉及到一些非常复杂的规则，不过我们不用在意。

对于简单的类模板，通常可以普通的类似函数模板一样的自动推导，比如前面提到的 `Test` 类型，又或者下面：

```cpp
template<class T>
struct A{
    A(T, T);
};
auto y = new A{1, 2}; // 分配的类型是 A<int>
```

new 表达式中一样可以。

同样的可以像函数模板那样加上许多的修饰：

```cpp
template<class T>
struct A {
    A(const T&, const T&);
};
```

多的就不用再提。

### 用户定义的推导指引

举个例子，我要让一个类模板，如果推导为 int，就让它实际成为 size_t：

```cpp
template<typename T>
struct Test{
    Test(T v) :t{ v } {}
private:
    T t;
};

Test(int) -> Test<std::size_t>;

Test t(1);      // t 是 Test<size_t>
```

如果要类模板 `Test` 推导为指针类型，就变成数组呢？

```cpp
template<typename T>
Test(T*) -> Test<T[]>;

char* p = nullptr;

Test t(p);      // t 是 Test<char[]>
```

推导指引的语法还是简单的，如果只是设计具体类型，那么只需要：

**`模板名称(类型a)->模板名称<想要让类型a被推导为的类型>`**

如果涉及的是一类类型，那么就需要加上 `template`，然后使用它的模板形参。

---

我们提一个稍微有点难度的需求：

```cpp
template<class Ty, std::size_t size>
struct array {
    Ty arr[size];
};

::array arr{1, 2, 3, 4, 5};     // Error!
```

类模板 array 同时使用了类型模板形参与非类型模板形参，保有了一个成员是数组。

它无法被我们直接推导出类型，此时就需要我们自己**定义推导指引**。

