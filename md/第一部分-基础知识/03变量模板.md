# 变量模板

本节将介绍 C++14 变量模板

## 初识变量模板

变量模板不是变量，只有实例化的变量模板，编译器才会生成实际的变量。

变量模板实例化后简单的说**就是一个全局变量**。

### 定义变量模板

```cpp
template<typename T>
T v;
```

就这么简单，毫无难度。

当然了，既然是变量，自然可以有各种的修饰，比如 cv 限定，比如 `constexpr` ,当然也可以有初始化器，比如 `{}` 、`= xxx`。

```cpp
template<typename T>
constexpr T v{};
```

### 使用变量模板

```cpp
template<typename T>
constexpr T v{};

v<int>;     // 相当于 constexpr int v = 0;
```

我们知道 `constexpr` 附带了 `const` 类型，所以其实：

```cpp
std::cout << std::is_same_v<decltype(v<int>),const int> << '\n';
```

> [std::is_same_v](https://zh.cppreference.com/w/cpp/types/is_same) 其实也是个变量模板，在 C++17 引入。这里用来比较两个类型是否相同，如果相同返回 1，不相同返回 0。暂时不用纠结它是如何实现的，后续会手搓。

会打印 1，也就是 `v<int>` 的类型其实就是 `const int`。

---

我们再提出一个问题，`v<int>` 和 `v<double>` 有什么关系吗？

> 最早在函数模板中，我们强调了“**同一个函数模板生成的不同类型的函数，彼此之间没有任何关系**”，这句话放在类模板、变量模板中，也同样适用。

```cpp
std::cout << &v<int> << '\n';
std::cout << &v<double> << '\n';
```

以上示例打印的地址不会相同。

## 有默认实参的模板形参

变量模板和函数模板、类模板一样，支持模板形参有默认实参。

## 非类型模板形参

变量模板和函数模板、类模板一样，支持非类型模板形参。

## 可变参数变量模板

变量模板和函数模板、类模板一样，支持形参包与包展开。

## 变量模板分文件

变量模板和函数模板、类模板一样，通常写法不支持分文件，原因都一样。

# 总结

如果学到这里了，如果你注意到，函数模板、类模板、变量模板，很多语法是共通的，是越学越简单，代表你思考了。

后续还有很多内容是一起的，比如模板偏特化、全特化、显式实例化等。