# 模板全特化

本节将介绍模板全特化。

其实很多东西都能进行全特化，不过我们围绕着之前的内容：函数模板、类模板、变量模板来展开。

## 函数模板全特化

给出这样一个函数模板 `f`，你可以看到，它的逻辑是返回两个对象相加的结果，那么如果我有一个需求：“**如果我传的是一个 double 一个 int 类型，那么就让它们返回相减的结果**”。

```cpp
template<typename T,typename T2>
auto f(const T& a, const T2& b)  {
    return a + b;
}
```

> C++14 允许函数返回声明的 auto 占位符自行推导类型。

这种定制的需求很常见，此时我们就需要使用到模板全特化：

```cpp
template<>
auto f(const double& a, const int& b){
    return a - b;
}
```

> 当特化函数模板时，如果模板实参推导能通过函数实参提供，那么就**可以忽略它的模板实参**。

语法很简单，只需要先写一个 `template<>` 后面再实现这个函数即可。

---

不过我们其实有两种写法的，比如上面那个示例，我们还可以写明模板实参。

```cpp
template<>
auto f<double, int>(const double& a, const int& b) {
    return a - b;
}
```

个人建议写明更加明确，因为很多时候模板实参只是函数形参类型的**一部分**而已，比如上面的 `const double&`、`const int&` 只有 `double` 、`int` 是模板实参。

[使用](https://godbolt.org/z/G9bzsTP5a)：

```cpp
std::cout << f(2, 1) << '\n';    // 3
std::cout << f(2.1, 1) << '\n';  // 1.1
```