# 模板全特化

本节将介绍模板全特化。

其实很多东西都能进行全特化，不过我们围绕着之前的内容：函数模板、类模板、变量模板来展开。

## 函数模板全特化

给出这样一个函数模板 `f`，你可以看到，它的逻辑是返回两个对象相加的结果，那么如果我有一个需求：“**如果我传的是一个 double 一个 int 类型，那么就让它们返回相减的结果**”。

```cpp
template<typename T,typename T2>
auto f(const T& a, const T2& b)  {
    return a + b;
}
```

> C++14 允许函数返回声明的 auto 占位符自行推导类型。

这种定制的需求很常见，此时我们就需要使用到模板全特化：

```cpp
template<>
auto f(const double& a, const int& b){
    return a - b;
}
```

> 当特化函数模板时，如果模板实参推导能通过函数实参提供，那么就**可以忽略它的模板实参**。

语法很简单，只需要先写一个 `template<>` 后面再实现这个函数即可。

---

不过我们其实有两种写法的，比如上面那个示例，我们还可以写明模板实参。

```cpp
template<>
auto f<double, int>(const double& a, const int& b) {
    return a - b;
}
```

个人建议写明更加明确，因为很多时候模板实参只是函数形参类型的**一部分**而已，比如上面的 `const double&`、`const int&` 只有 `double` 、`int` 是模板实参。

[使用](https://godbolt.org/z/G9bzsTP5a)：

```cpp
std::cout << f(2, 1) << '\n';    // 3
std::cout << f(2.1, 1) << '\n';  // 1.1
```

## 类模板全特化

和函数模板一样，类模板一样可以进行全特化。

```cpp
template<typename T> // 主模板
struct is_void{
    static constexpr bool value = false;
};
template<>           // 对 T = void 的显式特化
struct is_void<void>{
    static constexpr bool value = true;
};

int main(){
    std::cout <<std::boolalpha<< is_void<char>::value << '\n';    // false
    std::cout << std::boolalpha << is_void<void>::value << '\n';  // true
}
```

我们使用全特化，实现了一个 `is_void` 判断模板类型实参是不是 `void` 类型。

虽然很简单，但我们还是稍微强调一下：同一个类模板实例化的不同的类，彼此之间毫无关系，而静态数据成员是属于类的，而不是模板类；模板类实例化的不同的类，他们的静态数据成员不是同一个，请注意。

---

我们知道标准库在 `C++17` 引入了 `is_xxx` 的 `_v` 的版本，就不需要再写 `::value` 了。所以我们也可以这么做，这会使用到变量模板。

```cpp
#include <iostream>

template<typename T> // 主模板
struct is_void{
    static constexpr bool value = false;
};
template<>           // 对 T = void 的显式特化
struct is_void<void>{
    static constexpr bool value = true;
};

template<typename T>
constexpr bool is_void_v = is_void<T>::value;

int main(){
    std::cout <<std::boolalpha<< is_void_v<char> << '\n';    // false
    std::cout << std::boolalpha << is_void_v<void> << '\n';  // true
}
```

---

我们再给出一个简单的示例：

```cpp
template<typename T>
struct X{
    void f()const{
        puts("f");
    }
};

template<>
struct X<int>{
    void f()const{
        puts("X<int>");
    }
    void f2()const{}

    int n;
};

int main(){
    X<void> x;
    X<int> x_i;
    x.f();         // 打印 f
    //x.f2();      // Error!
    x_i.f();       // 打印 X<int>
    x_i.f2();
}
```

我们要明白，写一个类的全特化，就相当于写一个自己新的类一样，你可以自己定义任何东西，不管是函数、数据成员、静态数据成员，等等；根据自己的需求。

## 变量模板全特化

```cpp
template<std::size_t N>
constexpr std::size_t v = N;

template<>
constexpr std::size_t v<10> = 100;

int main(){
    std::cout << v<1> << ' ' << v<2> << ' ' << v<10> << '\n';   // 1 2 100
}
```

语法形式都比较类似，也很简单，这个类模板是非类型的。我们特化了 v 的模板实参为 **10** 的情况，让 `v` 的值为 **100**。

```cpp
template<typename T>
constexpr bool is_void_v = false;

template<>
constexpr bool is_void_v<void> = true;

int main(){
    std::cout << std::boolalpha << is_void_v<char> << '\n';   // false
    std::cout << std::boolalpha << is_void_v<void> << '\n';   // true
}
```

上面的变量模板，模板是类型形参，我们根据类型进行全特化。我们特化了 is_void_v 的模板实参为 `void` 的情况，让 `v` 为 `true`。

## 细节

前面函数、类、变量模板的全特化都讲的很简单，示例也很简单，或者说语法本身大多数时候就是简单的。我们在这里进行一些更多的**补充一些细节**，以及问题：

- 如何特化一个类模板中的成员函数模板？
- 如何特化一个类中的成员函数模板？
- 如何特化一个类模板中的静态数据成员？
