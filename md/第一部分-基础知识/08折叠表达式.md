# 折叠表达式

C++17 折叠表达式让我们能以更加简单的语法形式，更加轻松的进行**形参包展开**。

本节也将重新复习形参包的知识，希望各位不要忘记了。

## 语法

```
( 形参包 运算符 ... )	           (1)	
( ... 运算符 形参包 )	           (2)	
( 形参包 运算符 ... 运算符 初值 )	   (3)	
( 初值 运算符 ... 运算符 形参包 )	   (4)
```

1. 一元右折叠
2. 一元左折叠
3. 二元右折叠
4. 二元左折叠

折叠表达式的实例化按以下方式展开成表达式 e：

1. 一元右折叠 `(E 运算符 ...)` 成为 `(E1 运算符 (... 运算符 (EN-1 运算符 EN)))`
2. 一元左折叠 `(... 运算符 E)` 成为 `(((E1 运算符 E2) 运算符 ...) 运算符 EN)`
3. 二元右折叠 `(E 运算符 ... 运算符 I)` 成为 `(E1 运算符 (... 运算符 (EN−1 运算符 (EN 运算符 I))))`
4. 二元左折叠 `(I 运算符 ... 运算符 E)` 成为 `((((I 运算符 E1) 运算符 E2) 运算符 ...) 运算符 EN)`
（其中 N 是包展开中的元素数量）

- ***折叠表达式是左折叠还是右折叠，取决于 `...` 是在“形参包”的左边还是右边。***

## 实现一个 print 函数

> - 以下代码来自[01函数模板.md](01函数模板.md) 中的可变参数模板的示例
>```cpp
>template<typename...Args>
>void print(const Args&...args){
>    int _[]{ (std::cout << args << ' ' ,0)... };
>}
>print("luse", 1, 1.2); // luse 1 1.2
>```

运用折叠表达式，我们可以简化 `print`，而不再需要创建愚蠢的数组对象 `_`。

```cpp
template<typename...Args>
void print(const Args&...args) {
    ((std::cout << args << ' '), ...);
}
print("luse", 1, 1.2); // luse 1 1.2
```

这显然是 (1)**一元右折叠**，我们一步一步分析：

`(std::cout << args << ' ')` 就是语法中指代的**形参包**（其实说的是含有形参包的运算符表达式）。那么 `,` 逗号就是运算符，最后 `...` 。然后最外层有括号 `()` 符合语法。

函数模板实例化、折叠表达式展开，大概就是：

```cpp
void print(const char(&args0)[5], const int& args1, const double& args2) {
    (std::cout << args0 << ' '), ((std::cout << args1 << ' '), (std::cout << args2 << ' '));
}
```

我不建议各位数括号，死记这个规则，知道大概的意思就行，运用逗号运算符进行这个折叠表达式还是简单的，多用用就好。

## 详细展示语法

折叠表达式这四种语法形式我们都需要学习，并且明白其区别，我们用一个一个示例来展示，你自然会感觉到区别，毕竟**运行结果不一样**。

你可以学不懂或用不到这所有形式，但我总得教。

### 一元折叠

```cpp
template<typename...Args>
void print(const Args&...args) {
    (...,(std::cout << args << ' '));
}
print("luse", 1, 1.2); // luse 1 1.2
```

这个示例就是参考我们上面用折叠表达式实现的 `print`，只不过一开始的是“一元右折叠”，而我们这个示例是“**一元左折叠**”。

如你所见，这个 `print` 不管使用左折叠还是右折叠，运行结果是一样的，这是为什么呢？

实例化展开后是这样：

```cpp
void print(const char(&args0)[5], const int& args1, const double& args2) {
    ((std::cout << args0 << ' '), (std::cout << args1 << ' ')), (std::cout << args2 << ' ');
}
```

其实这个括号根本不影响什么，我们可以得出结论：“*对于逗号运算符，一元左折叠和一元右折叠没有区别*”。

---

我们用一个非类型模板参数的变量模板来展示在一些情况下左折叠和右折叠是会造成不同结果的：

```cpp
template<int...I>
constexpr int v_right = (I - ...);  // 一元右折叠

template<int...I>
constexpr int v_left = (... - I);   // 一元左折叠

int main(){
    std::cout << v_right<4, 5, 6> << '\n';  //(4-(5-6)) 5
    std::cout << v_left<4, 5, 6> << '\n';   //((4-5)-6) 7
}
```

这个示例很好，那么简单总结一下：左折叠和右折叠是需要注意的，他们的效果可能不同。

其实按照以上示例效果 `(4-(5-6))` `((4-5)-6)` 还可以总结一段简单的话：***右折叠就是先算右边，左折叠就是先算左边***。

我知道你肯定有疑问了：

> 前面不是说了：“对于逗号运算符，一元左折叠和一元右折叠没有区别”，为啥这里还会有**谁先算**这种说法？

有这个想法就代表思考了，我们来讲一下。

逗号表达式其实也是右折叠先算右边，左折叠先算左边，但是但是，请注意：“**`,`**”，逗号不同于其他运算符；

比如 `(expr1,(expr2,expr3))` 和 `((expr1,expr2),expr3)` 因为逗号表达式的特性，从左往右顺序执行，逗号运算符本身不参与运算符，那么这些括号根本不影响什么，但是如果换成其他的运算符，比如 `-`，就不同了，`(expr1-(expr2-expr3))` 和 `((expr1-expr2)-expr3)` 显然不同，也就是前面的：`(4-(5-6))` `((4-5)-6)`。

**“先算”这个词，不是各位想象的那种，而是指代表达式，我们只是加上括号，表达式执行效果到底怎么样，这是根据运算符的。**

到此，我们讲明白了为什么逗号表达式一元左右折叠效果一样，以及有些情况效果不同。