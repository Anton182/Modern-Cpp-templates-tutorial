# 前言

在 C++20 引入了约束与概念，这一核心语言特性是所有使用模板的 C++ 开发者都期待的。

有了它，我们的模板可以有更多的静态检查，语法更加美观，写法更加容易，而不再需要利用古老的 **SFINAE**。

请务必学习完了上一章节内容；本节会一边为你教学约束与概念的语法，一边用 SFINAE 对比，让你意识到：***这是多么先进、简单的核心语言特性***。

# 约束与概念

类模板，函数模板，以及非模板函数（通常是类模板的成员），可以与一项约束（constraint）相关联，它指定了对模板实参的一些要求，这些要求可以被用于选择最恰当的函数重载和模板特化。

这种要求的具名集合被称为概念（concept）。每个概念都是一个谓词，它在编译时求值，并在将之用作约束时成为模板接口的一部分。

> - 为了区分概念和*概念*（concept），如果要表达 `concept`，我们统一“*概念*（concept）”。你可以先不看基本概念，关注我们的示例和下面的讲解。

> ***我需要写一个函数模板 `add`，想要要求传入的对象必须是支持 `operator+` 的，应该怎么写？***

此需求就是 `SFINAE` 中提到的，我们使用*概念*（concept）来完成。

```cpp
template<typename T>
concept Add = requires(T a) {
    a + a;
};

template<Add T>
auto add(const T& t1, const T& t2){
    std::puts("concept +");
    return t1 + t2;
}
```

我们使用关键字 `concept` 定义了一个*概念*（concept），命名为 `Add` 它的*要求序列*是（要求序列需要使用 `requires` 关键字引入）：`requires(T a) { a + a; }`  即要求 `f(T a)`、`a + a` 是合法表达式。

```cpp
template<Add T> // T 被 Add 约束
```

语法上就是把原本的 `typename` 、`class` 换成了我们定义的 `Add` *概念*（concept），语义和作用也非常的明确：

- **就是让这个概念约束模板类型形参 `T`，即要求 `T` 必须满足*要求序列* `T a` `a + a`**。如果不满足，则不会选择这个模板。

*概念*（concept），就如前面概念中说的：

> 每个概念都是一个**谓词**，它在**编译时求值**，并在将之用作约束时成为模板接口的一部分。

也就是说我们其实可以这样：

```cpp
std::cout << std::boolalpha << Add<int> << '\n';        // true
std::cout << std::boolalpha << Add<char[10]> << '\n';   // false
constexpr bool r = Add<int>;                            // true
```

我相信这非常的好理解，这些语法形式，合理且简单。
