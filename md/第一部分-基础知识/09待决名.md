# 待决名

本节，我们开始讲待决名

待决名在模板当中无处不在，只要你写模板，一定遇到并且处理过它，即使你可能是第一次听到“待决名”这个名字。

待决名是你学习模板中重要的一个阶段，以此就可以划分，“新手写模板”和”正常写模板“，**我们不但要知道，怎么写，不能怎么写，还要知道，为什么？**

>在模板（类模板和函数模板）定义中，某些构造的含义可以在不同的实例化间有所不同。特别是，类型和表达式可能会取决于类型模板形参的类型和非类型模板形参的值。

循序渐进，待决名的规则非常繁杂，我们用一个一个示例为你慢慢展示（只讲常见与重要的），从简单到困难。

## 待决名的 `typename` 消除歧义符

> **在模板（包括别名模版）的声明或定义中，不是当前实例化的成员且取决于某个模板形参的名字不会被认为是类型，除非使用关键词 typename 或它已经被设立为类型名（例如用 typedef 声明或通过用作基类名）**。

先用一个示例引入问题。

```cpp
template<typename T>
const T::type& f(const T&) {
    return 0;
}

struct X{
    using type = int;
};

int main(){
    X x;
    f(x);
}
```

以上代码会产生编译错误。

msvc 报错提示：

```txt
error C2061: 语法错误: 标识符“type”
error C2143: 语法错误: 缺少“;”(在“{”的前面)
error C2447: “{”: 缺少函数标题(是否是老式的形式表?)
error C2065: “x”: 未声明的标识符
error C3861: “f”: 找不到标识符
```

[gcc](https://godbolt.org/z/W8oMMavnY) ：

```txt

<source>:2:7: error: need 'typename' before 'T::type' because 'T' is a dependent scope
    2 | const T::type& f(const T&) {
      |       ^
      |       typename 
<source>: In function 'int main()':
<source>:12:5: error: 'f' was not declared in this scope
   12 |     f(x);
      |     ^
```

总的意思也很简单，**编译器不觉得你这个 `type` 是一个类型**。

我知道此时，很多人会想到使用一个关键字：**`typename`**。

我们只需要在 `T::type&` 前面加上 `typename` 就能够通过编译。

```cpp
template<typename T>
const typename T::type& f(const T&) {
    return 0;
}
```

我们使用这个函数模板，来套一下，一句一句分析我们最开始说的那些概念。

> 在模板（包括别名模版）的声明或定义中

我们函数模板 `f` 自然是在模板中，符合。

> 不是当前实例化的成员且取决于某个模板形参的名字

我们的 `T::type` 的确不是当前实例化的成员，当前实例化的是函数模板 `f`；`T::type` 的确是取决于我们的模板形参的名字，简单的说就是 `T::type` 是什么，取决于当前的函数模板。符合。

> 不会被认为是类型

是的，所以我们前面没有使用 `typename` 产生了编译错误。

> 除非使用关键词 typename 或它已经被设立为类型名（例如用 typedef 声明或通过用作基类名）

是的，我们后面的示例使用了 `typename` 就没有问题了，`T::type` 被认为是类型了。

