# 函数模板

本节将介绍函数模板

## 初识函数模板

函数模板[^1]不是函数，只有实例化[^2]函数模板，编译器才能生成实际的函数。不过在很多时候，它看起来就像普通函数一样。

### 定义模板

下面是一个函数模板，返回两个对象中较大的那个：

```cpp
template<typename T>
T max(T a,T b){
    return a > b ? a : b;
}
```

这应该很简单，即使我们还没有开始讲述函数模板的语法。

如果要声明一个函数模板，我们通常要使用：

```cpp
template< 形参列表 > 函数声明
```

我们前面示例中的形参列表是 `typename T`，关键字 typename 顾名思义，引入了一个类型形参。

类型形参是 T，也可以使用其他标识符作为类型形参名（T 或 Ty 等，是约定的惯例），你也可以在需要的时候自定义一些有明确意义的名字。在调用函数模板 `max` 时，根据传入参数，编译器可以推导出类型形参的类型，实例化函数模板。我们需要传入支持函数模板操作的类型，如 int 或 重载了 `>` 运算符的类。注意 `max` 的 `return` 这意味着我们的模板形参 T 还需要是可复制/移动的，以便返回。

> C++17 之前，类型 T 必须是可复制或移动才能传递参数。C++17 以后，即使复制构造函数和移动构造函数都无效，因为 C++17 强制的[复制消除](https://zh.cppreference.com/w/cpp/language/copy_elision)，也可以传递临时纯右值。

因为一些历史原因，我们也可以使用 class 关键字来定义模板类型形参。所以先前的模板 `max` 可以**等价于**:

```cpp
template<class T>
T max(T a,T b){
    return a > b ? a : b;
}
```

但是与类声明不同，在声明函数类型形参时，不能使用 struct。

[^1]: 注：函数模板自身并不是类型、函数或任何其他实体。不会从只包含模板定义的源文件生成任何代码。模板只有实例化才会有代码出现。

[^2]: 注：术语”实例化“，在模板语境中指代的是编译器能确定各模板实参（可以是根据传入的参数推导，又或者是自己显示指明模板的实参）从而编译器能生成实际的函数（或从类模板生成类）。

#### 使用模板

下面展示了如何使用函数模板 `max()`

```cpp
#include <iostream>

template<typename T>
T max(T a, T b) {
    return a > b ? a : b;
}

struct Test{
    int v_{};
    Test() = default;
    Test(int v) :v_(v) {}
    bool operator>(const Test& t) const{
        return this->v_ > t.v_;
    }
};

int main(){
    int a{ 1 };
    int b{ 2 };
    std::cout << "max(a, b) : " << ::max(a, b) << '\n';

    Test t1{ 10 };
    Test t2{ 20 };
    std::cout << "max(t1, t2) : " << ::max(t1, t2).v_ << '\n';

}
```

> 看起来的确和调用普通函数没区别，那么这样调用和普通函数相比，编译器会做什么呢？

编译器会**实例化两个函数**，也就是生成了一个参数为 int 的 max 函数，一个参数为 Test 的函数。

```cpp
int max(int a, int b)
{
  return a > b ? a : b;
}

Test max(Test a, Test b)
{
  return a > b ? a : b;
}
```

我们可以使用 [cppinsights](https://cppinsights.io/) 验证我们的想法。

用一句非常不严谨的话来说：

- **模板，只有你“用”了它，它才会生成实际的函数**。

并且需要注意，同一个函数模板生成的不同类型的函数，彼此之间没有任何关系。

---

除了让编译器自己去推导函数模板的形参类型以外，我们还可以自己显式的指明：

```cpp
template<typename T>
T max(T a, T b) {
    return a > b ? a : b;
}


int main(){
    int a{ 1 };
    int b{ 2 };
    max(a, b);          // 函数模板 max 被推导为 max<int>

    max<double>(a, b);  // 传递模板类型实参，函数模板 max 为 max<double>
}
```

## 模板参数推导

当使用函数模板（如 max()）时，模板参数可以由传入的参数推导。如果类型 T 传递两个 int 型参数，那编译器就会认为 T 是 int 型。

然而，T 可能只是类型的“一部分”。若声明 max() 使用 `const&` ：

```cpp
template<typename T>
T max(const T& a, const T& b) {
    return a > b ? a : b;
}
```

如果我们 `max(1, 2)` 或者说 `max<int>(x,x)`，T 当然会是 int，但是函数形参类型会是 `const int&`。

不过我们需要注意，有不少情况是没有办法进行推导的：

```cpp
// 省略 max
using namespace std::string_literals;

int main(){
    max(1, 1.2);            // Error 无法确定你的 T 到底是要 int 还是 double
    max("luse"s, "乐");     // Error 无法确定你的 T 到底是要 std::string 还是 const char[N]
}
```

那么我们如何处理这种错误呢？可以使用前面提到的**显式指定函数模板的（T）类型**。

```cpp
max<double>(1, 1.2);           
max<std::string>("luse"s, "乐");
```

又或者说显式类型转换：

```cpp
max(static_cast<double>(1), 1.2);
```

但是 std::string 没有办法如此操作，我们可以显式的构造一个无名临时对象：

```cpp
max("luse"s, std::string("乐"));    // Error 为什么？
```

此时就不是我们的 `T` 不明确了，而是函数模板 `max` 不明确，它会和标准库的 `std::max` 产生冲突，虽然我们没有使用 `std::`，但是根据 C++ 的查找规则，（实参依赖查找）[ADL](https://zh.cppreference.com/w/cpp/language/adl)，依然可以查找到。

那么我们如何解决呢？很简单，进行有限定名字查找，即使用 `::` 或 `std::` 说明，你到底要调用 “全局作用域”的 max，还是 std 命名空间中的 max。

```cpp
::max("luse"s, std::string("乐"));gengx
```

